<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>vue组件runtime-dom</title>
  </head>

  <body>
    <div id="app"></div>
  </body>
  <script src="../../../node_modules/@vue/runtime-dom/dist//runtime-dom.global.js"></script>
  <!-- vue内部的运行时模块-开发环境的;组件中this.$attrs是响应式对象; -->

  <!-- <script src="../../../node_modules/@vue/runtime-dom/dist//runtime-dom.global.prod.js"></script> -->
  <!-- vue内部的运行时模块-生产环境的;组件中this.$attrs不是响应式对象; -->

  <!-- <script src="./runtime-dom.global.js"></script> -->
  <!-- 自己的运行时模块; -->

  <script>
    /* const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const VueComponent = {
      setup(props, { emit }) {
        return () => {
          //可以看到h()中绑定事件时,前面要加`on`,同时首字母大写;
          //同时触发自定义事件时,前面不需要加`on`;
          return h("p", { onClick: () => emit("xxx", "组件内入参") }, "方");
        };
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); //在h()函数中绑定事件时,前面要加`on`,同时首字母大写; */

    /* const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const VueComponent = {
      setup(props, { emit }) {
        return () => {
          //同时触发自定义事件时,前面不需要加`on`;
          //如果前面加`on`,会发现子组件触发的事件在父组件中并不是`onXxx`;
          return h("p", { onClick: () => emit("onXxx", "组件内入参") }, "方");
        };
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); */

    /* const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const VueComponent = {
      setup(props, { emit }) {
        return () => {
          return h("p", { onClick: () => emit("xxx", "组件内入参") }, "方");
        };
      },
    };
    //vue里面,@绑定的事件,会变成`onX`,即`前面加on,同时事件名首字母大写`;
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); */

    /* const {
      createRenderer,
      h,
      render,
      Text,
      Fragment,
      ref,
      getCurrentInstance,
    } = VueRuntimeDOM;
    const VueComponent = {
      setup(props, { emit }) {
        return () => {
          const instance = getCurrentInstance();//取得组件实例;
          console.log("instance--->", instance);//可以看到传入的事件onXxx是绑定在instance.vnode.props上的;
          return h("p", { onClick: () => emit("xxx", "组件内入参") }, "方");
        };
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); */

    /* //测试自己的emit():
    const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const VueComponent = {
      setup(props, { emit }) {
        return () => {
          return h("p", { onClick: () => emit("xxx", "组件内入参") }, "方一");
        };
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); */

    /* //插槽;
    const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const MyComponent = {
      render() {
        return h(Fragment, [
          //使用插槽要用`this.$slots`,`this.$slots`里放置用户放进来的组件或VNode节点;
          h("div", this.$slots.header()),
          h("div", this.$slots.footer()),
        ]);
      },
    };
    const VueComponent = {
      render() {
        //children如果是对象,说明是组件的插槽;
        //组件的插槽是个对象类型,并且如果组件的props为空,要设置为null,否则会认为插槽是个props;
        return h(MyComponent, null, {
          header: () => h("p", "header插槽的内容"),
          footer: () => h("p", "footer插槽的内容"),
        });
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); */

    /* //插槽;
    const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const MyComponent = {
      render() {
        return h(Fragment, [
          h("div", this.$slots.header()),
          h("div", this.$slots.footer()),
        ]);
      },
    };
    const VueComponent = {
      render() {
        //不传null就报错;
        return h(MyComponent, {
          header: () => h("p", "header插槽的内容"),
          footer: () => h("p", "footer插槽的内容"),
        });
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); */

    /* //插槽;
    //组件的插槽是一个对象,放着映射关系,渲染组件的时候去映射表中查找;
    const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const MyComponent = {
      render() {
        return h(Fragment, [
          h("div", this.$slots.header()),
          h("div", this.$slots.main()),
          h("div", this.$slots.footer()),
        ]);
      },
    };
    const VueComponent = {
      render() {
        return h(MyComponent, null, {
          header: () => h("p", "header插槽的内容"),
          footer: () => h("p", "footer插槽的内容"),
          main: () => h("h1", "main插槽的内容"),
        });
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app); */

    //插槽;
    const { createRenderer, h, render, Text, Fragment, ref } = VueRuntimeDOM;
    const MyComponent = {
      setup(props, ctx) {
        console.log("查看vue中的上下文:ctx--->", ctx);
        return {};
      },
      render() {
        return h(Fragment, [
          h("div", this.$slots.header()),
          h("div", this.$slots.main()),
          h("div", this.$slots.footer()),
        ]);
      },
    };
    const VueComponent = {
      render() {
        return h(MyComponent, null, {
          header: () => h("p", "header插槽的内容"),
          footer: () => h("p", "footer插槽的内容"),
          main: () => h("h1", "main插槽的内容"),
        });
      },
    };
    render(h(VueComponent, { onXxx: (value) => alert(value) }), app);
  </script>
</html>
